<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>TEDD-Ranker</title>
  <link rel="stylesheet" href="style.css" />
  <style>
    /* New inline styles for dynamic input feedback */
    .disabled {
      background-color: #e0e0e0;
      pointer-events: none;
    }
    .error {
      color: red;
      font-size: 12px;
    }
    /* Simple styling for update buttons in each section */
    .section-update-btn {
      margin-top: 10px;
      margin-bottom: 10px;
    }
    /* Styling for input rules block */
    .input-rules {
      background-color: #f9f9f9;
      border: 1px solid #ccc;
      padding: 10px;
      margin-bottom: 15px;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <h1>TEDD-Ranker</h1>

  <!-- ===== Efficiency Section ===== -->
  <div class="section-container" id="efficiencySection">
    <h2>Efficiency Indicators</h2>
    <!-- New Input Rules Block -->
    <div class="input-rules">
      <strong>Input Rules:</strong>
      <ul>
        <li><strong>SEM:</strong> One or more comma‚Äêseparated values (e.g. <em>1.2, 1.4</em>).</li>
        <li><strong>BLM:</strong> Either a single value (e.g. <em>1.0</em>) or exactly as many values as SEM (e.g. <em>1.0, 1.0</em>).</li>
        <li><strong>PIR:</strong> If provided directly, only one value is allowed (e.g. <em>0.95</em>).</li>
        <li><strong>SDF:</strong> Must be exactly one value (e.g. <em>0.125</em>).</li>
      </ul>
    </div>
    <!-- Efficiency Input Fields -->
    <div class="input-container">
      <div>
        <label for="effMethodNames">Method Name:</label>
        <input type="text" id="effMethodNames" placeholder="e.g. AlpaGasus_demo" />
      </div>
      <div>
        <label for="pirType">PIR Type:</label>
        <select id="pirType">
          <option value="same_win_rate">Same Win Rate</option>
          <option value="same_benchmark">Same Benchmark</option>
          <option value="other_benchmark">Other Benchmark</option>
        </select>
      </div>
      <div>
        <label for="SEM">SEM values:</label>
        <input type="text" id="SEM" placeholder="e.g. 1.2, 1.4" />
        <div id="semError" class="error"></div>
      </div>
      <div>
        <label for="BLM">BLM values:</label>
        <input type="text" id="BLM" placeholder="e.g. 1.0 or 1.0, 1.0" />
        <div id="BLMError" class="error"></div>
      </div>
      <!-- New PIR input field for direct PIR value -->
      <div>
        <label for="PIR">PIR value:</label>
        <input type="text" id="PIR" placeholder="e.g. 0.95" />
        <div id="pirError" class="error"></div>
      </div>
      <div>
        <label for="SDF">SDF value:</label>
        <input type="text" id="SDF" placeholder="e.g. 0.125" />
        <div id="sdfError" class="error"></div>
      </div>
    </div>
    <!-- NEW: Separate Update Efficiency Button -->
    <div class="section-update-btn">
      <button id="updateEfficiencyBtn">Update Efficiency</button>
    </div>

    <!-- Efficiency Table & Plot in one row -->
    <div class="row-container">
      <div class="half">
        <div class="table-container">
          <table id="efficiencyTable" class="leaderboard-table">
            <thead>
              <tr>
                <th>Efficiency Rank</th>
                <th>Method</th>
                <th>Performance Improvement Ratio (PIR)</th>
                <th>Selected Dataset Fraction (SDF)</th>
                <th>Actions</th> <!-- NEW column for delete buttons -->
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>
      <div class="half">
        <div class="plot-container">
          <canvas id="efficiencyCanvas" width="700" height="500"></canvas>
        </div>
      </div>
    </div>
  </div>

<!-- ===== Feasibility Section ===== -->
<div class="section-container" id="feasibilitySection">
  <h2>Feasibility Indicators</h2>
  <!-- Input Rules for Feasibility -->
  <div class="input-rules">
    <strong>Input Rules:</strong>
    <ul>
      <li><strong># Trained LLMs:</strong> How many LLMs are trained during construction of your Data Selector.</li>
      <li><strong>Steps:</strong> How many algorithm steps do you have for a data selection process. For counting method, please refer to paper's appendix A.5. (Only the number before the bracket is used for ranking.)</li>
      <li><strong>Rep: Whether your work has open-source codes. </strong> Select <em>true</em> or <em>false</em>.</li>
      <li><strong>Model Free:</strong> If the selector model is changed, will the performance be influenced?</li>
      <li><strong>Dataset Free:</strong> If the candidate dataset is changed, do you need to re-train the selector?</li>
      <li><strong>ChatGPT Free</strong>: Does your selection rely on ChatGPT/GPT-4 like proprietary models?</li>
    </ul>
    <strong>Ranking Algorithm:</strong>
      <ul>
        <li><strong>Feasibility Rank</strong> is based on ranking of each work's <strong>Simplicity Rank + Flexibility Rank</strong>.</li>
        <li><strong>Simplicity Rank</strong> is based on ranking of each work's <strong>Simplicity Penalty = 2*LLMCount + 1*Steps + 1*NotReproducible.</strong></li>
        <li>Smaller Simplicity Penalty --> Higher Simplicity Rank</li>
        <li><strong>Flexibility Rank</strong> is based on ranking of each work's <strong>Flexibility Penalty = 3*NotModelFree + 2*NotDatasetFree + 1*NotGPTFree.</strong></li>
        <li>Smaller Flexibility Penalty --> Higher Flexibility Rank</li>
      </ul>
  </div>
  <div class="row-container feasibility-row">
    <div class="table-wide">
      <div class="table-container">
        <table id="feasibilityTable" class="leaderboard-table">
          <thead>
            <tr>
              <th>Feasibility Rank</th>
              <th>Method</th>
              <th># Trained LLMs</th>
              <th>Steps</th>
              <th>Rep.</th>
              <th>Simplicity Rank</th>
              <th>Model Free</th>
              <th>Dataset Free</th>
              <th>ChatGPT Free</th>
              <th>Flexibility Rank</th>
              <!-- NEW: Add Actions column -->
              <th>Actions</th>
            </tr>
          </thead>
          <tbody></tbody>
          <tfoot>
            <tr>
                <td>Auto</td> <!-- Feasibility Rank -->
                <td><input type="text" id="newFeasMethod" placeholder="Method Name" /></td>
                <td><input type="text" id="newFeasLLM" placeholder="#LLMs" /></td>
                <td><input type="text" id="newFeasSteps" placeholder="Steps" /></td>
                <td>
                    <select id="newFeasRep">
                        <option value="true">&#10004;</option>
                        <option value="false">&#10007;</option>
                    </select>
                </td>
                <td>Auto</td> <!-- Simplicity Rank -->
                <td>
                    <select id="newFeasModelFree">
                        <option value="true">&#10004;</option>
                        <option value="false">&#10007;</option>
                    </select>
                </td>
                <td>
                    <select id="newFeasDataFree">
                        <option value="true">&#10004;</option>
                        <option value="false">&#10007;</option>
                    </select>
                </td>
                <td>
                    <select id="newFeasChatFree">
                        <option value="true">&#10004;</option>
                        <option value="false">&#10007;</option>
                    </select>
                </td>
                <td>Auto</td> <!-- Flexibility Rank -->
                <!-- NEW: Empty cell for potential new action -->
                <td></td>
            </tr>
        </tfoot>
        </table>
      </div>
    </div>

    <div class="plot-narrow">
      <div class="plot-container feasibility-plot">
      <!-- <div class="plot-container"> -->
        <canvas id="feasibilityCanvas" width="700" height="700"></canvas>
      </div>
    </div>
  </div>
  <div class="section-update-btn">
    <button id="updateFeasibilityBtn">Update Feasibility</button>
  </div>
</div>

  <!-- Bottom Save Button (unchanged) -->
  <div class="button-container">
    <button id="saveBtn">Save Data &amp; Plots</button>
  </div>

  <script>
    // ===============================================================
    // Efficiency Calculation Functions (Updated for new input interactions)
    // ===============================================================
    // Global efficiencyData (default data)
    // --- Updated default values for SDF and PIR ---
    // let efficiencyData = [
    //   { method: "AlpaGasus", sdf: 0.17, pir: 1.284 },
    //   { method: "Superfiltering", sdf: 0.05, pir: 1.475 },
    //   { method: "InsTag", sdf: 0.0196, pir: 1.344 },
    //   { method: "DEITA", sdf: 0.1, pir: 1.426 },
    //   { method: "InstructionGPT-4", sdf: 0.06, pir: 1.443 },
    //   { method: "Nuggets", sdf: 0.15, pir: 1.519 },
    //   { method: "IFD", sdf: 0.05, pir: 1.747 },
    //   { method: "LESS", sdf: 0.05, pir: 1.491 },
    //   { method: "Instruction-Mining", sdf: 0.025, pir: 1.400 },
    //   { method: "SHED", sdf: 0.09, pir: 1.460 },
    //   { method: "CaR", sdf: 0.0196, pir: 1.343 },
    //   { method: "SelectIT", sdf: 0.2, pir: 1.653 }
    // ];
    // let efficiencyData = [
    //   { method: "AlpaGasus", sdf: 0.173, pir: 1.284 },
    //   { method: "Superfiltering", sdf: 0.05, pir: 1.425 },
    //   { method: "InsTag", sdf: 0.02, pir: 1.291 },
    //   { method: "DEITA", sdf: 0.1, pir: 1.426 },
    //   { method: "InstructionGPT-4", sdf: 0.058, pir: 1.385 },
    //   { method: "Nuggets", sdf: 0.145, pir: 1.374 },
    //   { method: "IFD", sdf: 0.05, pir: 1.697 },
    //   { method: "LESS", sdf: 0.05, pir: 1.4 },
    //   { method: "Instruction-Mining", sdf: 0.025, pir: 1.375 },
    //   { method: "SHED", sdf: 0.09, pir: 1.468 },
    //   { method: "CaR", sdf: 0.0196, pir: 1.343 },
    //   { method: "SelectIT", sdf: 0.2, pir: 1.653 }
    // ];
    let efficiencyData = [
      { method: "AlpaGasus", sdf: 0.173, pir: 1.284 },
      { method: "Superfiltering", sdf: 0.05, pir: 1.475 },
      { method: "InsTag", sdf: 0.02, pir: 1.344 },
      { method: "DEITA", sdf: 0.1, pir: 1.426 },
      { method: "InstructionGPT-4", sdf: 0.058, pir: 1.443 },
      { method: "Nuggets", sdf: 0.145, pir: 1.519 },
      { method: "IFD", sdf: 0.05, pir: 1.747 },
      { method: "LESS", sdf: 0.05, pir: 1.491 },
      { method: "Instruction-Mining", sdf: 0.025, pir: 1.400 },
      { method: "SHED", sdf: 0.09, pir: 1.460 },
      { method: "CaR", sdf: 0.0196, pir: 1.343 },
      { method: "SelectIT", sdf: 0.2, pir: 1.653 }
    ];


    // --- NEW: assign a global order to each work for tie-breaking ---
    let nextEfficiencyOrder = 1;
    efficiencyData.forEach(d => { d.order = nextEfficiencyOrder++; });

    function linearTransform(x, x_vals, y_vals) {
      let x1 = x_vals[0], x2 = x_vals[1];
      let y1 = y_vals[0], y2 = y_vals[1];
      let m = (y2 - y1) / (x2 - x1);
      let b = y1 - m * x1;
      return m * x + b;
    }

    function transform(sameBenchPir = 0, othBenchPir = 0) {
      if (sameBenchPir !== 0) {
        return linearTransform(sameBenchPir, [0.949, 1.01], [1.284, 1.475]);
      } else if (othBenchPir !== 0) {
        return linearTransform(othBenchPir, [0.985, 1.000], [1.344, 1.426]);
      }
      return null;
    }

    // Updated getPIR: supports either a direct PIR input OR calculation from SEM/BLM.
    // Also supports two valid input cases: (a) multiple SEM with a single BLM (broadcast) or (b) paired SEM and BLM.
    function getPIR(type, SEM = null, BLM = null, pir = null) {
      let PIR;
      if (pir !== null) {
        // Direct PIR input provided.
        PIR = pir;
      } else if (SEM !== null && BLM !== null) {
        if (BLM.length === 1 && SEM.length >= 1) {
          let pirArray = SEM.map(sem => sem / BLM[0]);
          pir = pirArray.reduce((acc, val) => acc + val, 0) / pirArray.length;
        } else if (SEM.length === BLM.length) {
          let pirArray = SEM.map((sem, i) => sem / BLM[i]);
          pir = pirArray.reduce((acc, val) => acc + val, 0) / pirArray.length;
        } else {
          return { error: "Invalid input: Provide either one BLM value with one or more SEM values, or equal-length arrays of SEM and BLM values." };
        }
        if (type === "same_win_rate") {
          PIR = pir;
        } else if (type === "same_benchmark") {
          PIR = transform(pir, 0);
        } else if (type === "other_benchmark") {
          PIR = transform(0, pir);
        }
      }
      return { result: PIR };
    }

    // --- Dynamic Input State Updates for Efficiency Section ---
    function updateEfficiencyInputStates() {
      const semInput = document.getElementById("SEM");
      const BLMInput = document.getElementById("BLM");
      const pirInput = document.getElementById("PIR");

      // If SEM or BLM have input, disable PIR.
      if (semInput.value.trim() !== "" || BLMInput.value.trim() !== "") {
        pirInput.disabled = true;
        pirInput.classList.add("disabled");
      } else {
        pirInput.disabled = false;
        pirInput.classList.remove("disabled");
      }

      // If PIR has input, disable SEM and BLM.
      if (pirInput.value.trim() !== "") {
        semInput.disabled = true;
        BLMInput.disabled = true;
        semInput.classList.add("disabled");
        BLMInput.classList.add("disabled");
      } else {
        semInput.disabled = false;
        BLMInput.disabled = false;
        semInput.classList.remove("disabled");
        BLMInput.classList.remove("disabled");
      }
    }

    // Add event listeners to update input states dynamically.
    document.getElementById("SEM").addEventListener("input", updateEfficiencyInputStates);
    document.getElementById("BLM").addEventListener("input", updateEfficiencyInputStates);
    document.getElementById("PIR").addEventListener("input", updateEfficiencyInputStates);

    // --- NEW: Function to compute signed efficiency values and sort the efficiencyData array ---
    function sortEfficiencyData() {
      const canvas = document.getElementById("efficiencyCanvas");
      if (!canvas) return;
      const dpr = window.devicePixelRatio || 1;
      const W = canvas.width / dpr;
      const H = canvas.height / dpr;
      const pad = 60;
      const innerPad = 20;
      const minSDFdata = Math.min(...efficiencyData.map(d => d.sdf));
      const maxSDFdata = Math.max(...efficiencyData.map(d => d.sdf));
      const minSDF = Math.min(0.0, minSDFdata);
      const maxSDF = (maxSDFdata > 0.2 ? maxSDFdata : 0.2) * 1.05;
      const minPIRdata = Math.min(...efficiencyData.map(d => d.pir));
      let maxPIR = Math.max(...efficiencyData.map(d => d.pir));
      const minPIR = minPIRdata * 0.95;
      maxPIR = (maxPIR > 1.75 ? maxPIR : 1.75) * 1.05 + 0.01;
      const xScale = val => pad + ((val - minSDF) / (maxSDF - minSDF)) * (W - 2 * pad);
      const yScale = val => (H - pad) - ((val - minPIR) / (maxPIR - minPIR)) * (H - 2 * pad);

      const A = efficiencyData.find(d => d.method === "Instruction-Mining");
      const B = efficiencyData.find(d => d.method === "InstructionGPT-4");
      if (!A || !B) return;
      const dx = B.sdf - A.sdf;
      if (Math.abs(dx) < 1e-12) return;
      const slope = (B.pir - A.pir) / (B.sdf - A.sdf);
      const colorRectLeft = pad + innerPad;
      const colorRectRight = W - pad - innerPad;
      const leftSDF = minSDF + ((colorRectLeft - pad) / (W - 2 * pad)) * (maxSDF - minSDF);
      const rightSDF = minSDF + ((colorRectRight - pad) / (W - 2 * pad)) * (maxSDF - minSDF);
      const yAtLeft = A.pir + slope * (leftSDF - A.sdf);
      const yAtRight = A.pir + slope * (rightSDF - A.sdf);
      const X1 = colorRectLeft;
      const Y1 = yScale(yAtLeft);
      const X2 = colorRectRight;
      const Y2 = yScale(yAtRight);

      // Normal vector of baseline: n = (-(Y2 - Y1), X2 - X1) normalized
      const dxBase = X2 - X1;
      const dyBase = Y2 - Y1;
      const norm = Math.sqrt(dxBase * dxBase + dyBase * dyBase);
      const nx = -dyBase / norm;
      const ny = dxBase / norm;

      efficiencyData.forEach(d => {
        const px = xScale(d.sdf);
        const py = yScale(d.pir);
        const proj = projectPointToLine(px, py, X1, Y1, X2, Y2);
        const dxProj = px - proj[0];
        const dyProj = py - proj[1];
        const distance = Math.sqrt(dxProj * dxProj + dyProj * dyProj);
        const dot = dxProj * nx + dyProj * ny;
        const sign = (dot >= 0) ? 1 : -1;
        d.effVal = sign * distance;
      });

      // --- NEW: sort in descending order by efficiency (using a.effVal - b.effVal per instructions)
      efficiencyData.sort((a, b) => {
        if (a.effVal !== b.effVal) {
          return a.effVal - b.effVal;
        }
        if (a.method.toLowerCase() < b.method.toLowerCase()) return -1;
        if (a.method.toLowerCase() > b.method.toLowerCase()) return 1;
        return a.order - b.order;
      });


      // Add dense ranking for efficiency
      let efficiencyRank = {};
      let denseRank = 0;
      let prevEffVal = null;
      
      efficiencyData.forEach((d, i) => {
          if (i === 0 || Math.abs(d.effVal - prevEffVal) > 1e-6) {
              denseRank++;
              efficiencyRank[d.method] = denseRank;
              prevEffVal = d.effVal;
          } else {
              efficiencyRank[d.method] = denseRank;
          }
      });
      
      efficiencyData.forEach(d => {
          d.efficiencyRank = efficiencyRank[d.method];
      });
    }

    // --- Modified Efficiency Table Update Function ---
    function populateEfficiencyTable() {
      const effTbody = document.querySelector("#efficiencyTable tbody");
      // Do not clear table if error occurs.
      const SEMInput = document.getElementById("SEM").value.trim();
      const BLMInput = document.getElementById("BLM").value.trim();
      const SDFInput = document.getElementById("SDF").value.trim();
      const PIRInputVal = document.getElementById("PIR").value.trim();

      // NEW: Check that PIR and SDF inputs (if provided) contain only one value.
      if (PIRInputVal !== "" && PIRInputVal.split(",").length > 1) {
        document.getElementById("pirError").textContent = "PIR must be a single value.";
        return;
      } else {
        document.getElementById("pirError").textContent = "";
      }
      if (SDFInput !== "" && SDFInput.split(",").length > 1) {
        document.getElementById("sdfError").textContent = "SDF must be a single value.";
        return;
      } else {
        document.getElementById("sdfError").textContent = "";
      }

      // If new efficiency input is provided, update the global efficiencyData array.
      if (SDFInput !== "") {
        if (SEMInput !== "" || BLMInput !== "" || PIRInputVal !== "") {
          const methodNamesInput = document.getElementById("effMethodNames").value.trim();
          const methods = methodNamesInput ? methodNamesInput.split(",").map(s => s.trim()) : [];
          const pirType = document.getElementById("pirType").value;
          const SEM = SEMInput ? SEMInput.split(",").map(Number) : [];
          const BLM = BLMInput ? BLMInput.split(",").map(Number) : [];
          const SDF = SDFInput.split(",").map(Number);

          if (PIRInputVal === "" && ((SEM.length > 0 || BLM.length > 0) && (SEM.length !== BLM.length && BLM.length !== 1))) {
            document.getElementById("semError").textContent = "SEM and BLM must have the same number of values or BLM must be a single value.";
            document.getElementById("BLMError").textContent = "SEM and BLM must have the same number of values or BLM must be a single value.";
            return;
          } else {
            document.getElementById("semError").textContent = "";
            document.getElementById("BLMError").textContent = "";
          }

          let pirValue;
          if (PIRInputVal !== "") {
            pirValue = parseFloat(PIRInputVal);
          } else {
            const result = getPIR(pirType, SEM, BLM, null);
            if (result.error) {
              alert(result.error);
              return;
            }
            pirValue = result.result;
          }

          // Append new entries (one for the single SDF value) with an order property.
          for (let i = 0; i < SDF.length; i++) {
            const methodName = methods[i] ? methods[i] : "Method " + (efficiencyData.length + 1);
            efficiencyData.push({
              method: methodName,
              sdf: SDF[i],
              pir: pirValue,
              order: nextEfficiencyOrder++
            });
          }

          // Clear the input fields after adding.
          document.getElementById("effMethodNames").value = "";
          document.getElementById("SEM").value = "";
          document.getElementById("BLM").value = "";
          document.getElementById("SDF").value = "";
          document.getElementById("PIR").value = "";
          updateEfficiencyInputStates();
        }
      }

      // --- NEW: Sort the efficiencyData array based on computed efficiency values ---
      sortEfficiencyData();

      // Clear and re-populate table from the entire efficiencyData array.
      effTbody.innerHTML = "";
      efficiencyData.forEach(d => {
        const tr = document.createElement("tr");
        let deleteButtonHTML = "";
        // Only allow deletion for non-baseline methods.
        if (d.method !== "Instruction-Mining" && d.method !== "InstructionGPT-4") {
          deleteButtonHTML = `<button class="deleteBtn" data-method="${d.method}" data-order="${d.order}">Delete</button>`;
        }
        tr.innerHTML = `<td>${d.efficiencyRank}</td>
                        <td>${d.method}</td>
                        <td>${(typeof d.pir === "number") ? d.pir.toFixed(4) : d.pir}</td>
                        <td>${d.sdf}</td>
                        <td>${deleteButtonHTML}</td>`;
        effTbody.appendChild(tr);
      });

      // Attach event listeners to delete buttons.
      document.querySelectorAll(".deleteBtn").forEach(btn => {
        btn.addEventListener("click", function() {
          const methodToDelete = this.getAttribute("data-method");
          const orderToDelete = parseInt(this.getAttribute("data-order"));
          efficiencyData = efficiencyData.filter(d => {
            // Match both method and order to ensure uniqueness.
            return !(d.method === methodToDelete && d.order === orderToDelete);
          });
          populateEfficiencyTable();
          drawEfficiencyPlot();
        });
      });
    }

    // Separate update functions for Efficiency and Feasibility.
    function updateEfficiency() {
      populateEfficiencyTable();
      drawEfficiencyPlot();
    }

    function updateFeasibility() {
      addNewFeasibilityRow();
      populateFeasibilityTable();
      drawFeasibilityPlot();
    }

    // ===============================================================
    // Feasibility Data and Rankings
    // ===============================================================
    const feasibilityData = [
      {
        method: "AlpaGasus",
        llmCount: "0",
        steps: "2(1)",
        rep: false,
        modelFree: true,
        datasetFree: true,
        chatGPTFree: false,
      },
      {
        method: "InsTag",
        llmCount: "0",
        steps: "3(1)",
        rep: false,
        modelFree: true,
        datasetFree: true,
        chatGPTFree: false,
      },
      {
        method: "CaR",
        llmCount: "0",
        steps: "4(0)",
        rep: true,
        modelFree: true,
        datasetFree: true,
        chatGPTFree: true,
      },
      {
        method: "Nuggets",
        llmCount: "0",
        steps: "4(2)",
        rep: true,
        modelFree: true,
        datasetFree: true,
        chatGPTFree: true,
      },
      {
        method: "SelectIT",
        llmCount: "0",
        steps: "4(3)",
        rep: true,
        modelFree: true,
        datasetFree: true,
        chatGPTFree: true,
      },
      {
        method: "Superfiltering",
        llmCount: "1*",
        steps: "3(1*)",
        rep: true,
        modelFree: false,
        datasetFree: false,
        chatGPTFree: true,
      },
      {
        method: "IFD",
        llmCount: "1",
        steps: "3(1)",
        rep: true,
        modelFree: false,
        datasetFree: false,
        chatGPTFree: true,
      },
      {
        method: "LESS",
        llmCount: "1",
        steps: "4(2)",
        rep: true,
        modelFree: false,
        datasetFree: false,
        chatGPTFree: true,
      },
      {
        method: "DEITA",
        llmCount: "2",
        steps: "5(4)",
        rep: true,
        modelFree: false,
        datasetFree: false,
        chatGPTFree: false,
      },
      {
        method: "InstructionGPT-4",
        llmCount: "30",
        steps: "4(1)",
        rep: true,
        modelFree: false,
        datasetFree: true,
        chatGPTFree: false,
      },
      {
        method: "SHED",
        llmCount: "500",
        steps: "3(0)",
        rep: true,
        modelFree: false,
        datasetFree: false,
        chatGPTFree: true,
      },
      {
        method: "Instruction-Mining",
        llmCount: "129",
        steps: "4(0)",
        rep: false,
        modelFree: false,
        datasetFree: true,
        chatGPTFree: false,
      }
    ];

    function computeFeasibilityRanks() {
      // First compute weighted scores for simplicity and flexibility.
      feasibilityData.forEach(d => {
        let llm = parseFloat(d.llmCount.replace(/[^0-9\.]/g, ""));
        let stepsMatch = d.steps.match(/^(\d+)/);
        let stepsNum = stepsMatch ? parseFloat(stepsMatch[1]) : 0;
        let repPenalty = d.rep ? 0 : 1;
        let llmWeight = 2;
        if(d.method === "Superfiltering") { llmWeight = 1.5; }
        // If llm > 100, assign a fixed simplicity score of 200 as per requirements.
        let simplicityScore = (llm > 100) ? 200 : (llm * llmWeight + stepsNum + repPenalty);
        d.simplicityScore = simplicityScore;
        let modelPenalty = d.modelFree ? 0 : 3;
        let dataPenalty = d.datasetFree ? 0 : 2;
        let chatPenalty = d.chatGPTFree ? 0 : 1;
        let flexibilityScore = modelPenalty + dataPenalty + chatPenalty;
        d.flexibilityScore = flexibilityScore;
      });

      // --- Dense ranking for simplicity ---
      let sortedSimplicity = [...feasibilityData].sort((a, b) => a.simplicityScore - b.simplicityScore);
      let simplicityRank = {};
      let denseRank = 0;
      let prevScore = null;
      for (let i = 0; i < sortedSimplicity.length; i++) {
          let score = sortedSimplicity[i].simplicityScore;
          if (i === 0 || Math.abs(score - prevScore) > 1e-6) {
              denseRank++;
              simplicityRank[sortedSimplicity[i].method] = denseRank;
              prevScore = score;
          } else {
              simplicityRank[sortedSimplicity[i].method] = denseRank;
          }
      }
      feasibilityData.forEach(d => { d.simplicityRank = simplicityRank[d.method]; });

      // --- Dense ranking for flexibility ---
      let sortedFlex = [...feasibilityData].sort((a, b) => a.flexibilityScore - b.flexibilityScore);
      let flexibilityRank = {};
      denseRank = 0;
      prevScore = null;
      for (let i = 0; i < sortedFlex.length; i++) {
          let score = sortedFlex[i].flexibilityScore;
          if (i === 0 || Math.abs(score - prevScore) > 1e-6) {
              denseRank++;
              flexibilityRank[sortedFlex[i].method] = denseRank;
              prevScore = score;
          } else {
              flexibilityRank[sortedFlex[i].method] = denseRank;
          }
      }
      feasibilityData.forEach(d => { d.flexibilityRank = flexibilityRank[d.method]; });

      // --- Dense ranking for final feasibility (sum of simplicityRank and flexibilityRank) ---
      let sortedFinal = [...feasibilityData].sort((a, b) => (a.simplicityRank + a.flexibilityRank) - (b.simplicityRank + b.flexibilityRank));
      let finalRankMap = {};
      denseRank = 0;
      prevScore = null;
      for (let i = 0; i < sortedFinal.length; i++) {
          let sum = sortedFinal[i].simplicityRank + sortedFinal[i].flexibilityRank;
          if (i === 0 || Math.abs(sum - prevScore) > 1e-6) {
              denseRank++;
              finalRankMap[sortedFinal[i].method] = denseRank;
              prevScore = sum;
          } else {
              finalRankMap[sortedFinal[i].method] = denseRank;
          }
      }
      feasibilityData.forEach(d => {
          d.feasibilityRank = finalRankMap[d.method];
      });
    }



    // Add sorting function for feasibility table display
    function sortFeasibilityData() {
        feasibilityData.sort((a, b) => {
            // Sort by feasibility rank (ascending)
            if (b.feasibilityRank !== a.feasibilityRank) {
                return a.feasibilityRank - b.feasibilityRank;
            }
            // Break tie with simplicity rank
            if (b.simplicityRank !== a.simplicityRank) {
                return a.simplicityRank - b.simplicityRank;
            }
            // Break tie with flexibility rank
            if (b.flexibilityRank !== a.flexibilityRank) {
                return a.flexibilityRank - b.flexibilityRank;
            }
            // Finally break tie alphabetically
            return b.method.localeCompare(a.method);
        });
    }

    // Modified populateFeasibilityTable to insert a delete button in the last column.
    function populateFeasibilityTable() {
      computeFeasibilityRanks();
      sortFeasibilityData();

      const feasTbody = document.querySelector("#feasibilityTable tbody");
      feasTbody.innerHTML = "";
      feasibilityData.forEach((d, index) => {
        const repVal = d.rep ? "&#10004;" : "&#10007;";
        const mfVal  = d.modelFree ? "&#10004;" : "&#10007;";
        const dfVal  = d.datasetFree ? "&#10004;" : "&#10007;";
        const cfVal  = d.chatGPTFree ? "&#10004;" : "&#10007;";
        const tr = document.createElement("tr");
        tr.innerHTML = `<td>${d.feasibilityRank}</td>
                        <td>${d.method}</td>
                        <td>${d.llmCount}</td>
                        <td>${d.steps}</td>
                        <td>${repVal}</td>
                        <td>${d.simplicityRank}</td>
                        <td>${mfVal}</td>
                        <td>${dfVal}</td>
                        <td>${cfVal}</td>
                        <td>${d.flexibilityRank}</td>
                        <td><button class="deleteFeasBtn" data-index="${index}">Delete</button></td>`;
        feasTbody.appendChild(tr);
      });

      // Attach event listeners to the delete buttons in feasibility table.
      document.querySelectorAll(".deleteFeasBtn").forEach(btn => {
        btn.addEventListener("click", function() {
          const indexToDelete = parseInt(this.getAttribute("data-index"));
          // Remove the element from feasibilityData array:
          feasibilityData.splice(indexToDelete, 1);
          // Refresh table and plot after deletion.
          populateFeasibilityTable();
          drawFeasibilityPlot();
        });
      });
    }

    // Adds a new feasibility row based on tfoot inputs.
    function addNewFeasibilityRow() {
      const fm = document.getElementById("newFeasMethod").value.trim();
      const fllm = document.getElementById("newFeasLLM").value.trim();
      const fsteps = document.getElementById("newFeasSteps").value.trim();
      const frep = document.getElementById("newFeasRep").value === "true";
      const fmf = document.getElementById("newFeasModelFree").value === "true";
      const fdf = document.getElementById("newFeasDataFree").value === "true";
      const fcf = document.getElementById("newFeasChatFree").value === "true";
      if (fm && fllm && fsteps) {
        feasibilityData.push({
          method: fm,
          llmCount: fllm,
          steps: fsteps,
          rep: frep,
          modelFree: fmf,
          datasetFree: fdf,
          chatGPTFree: fcf
        });
      }
    }
    function updateFeasibility() {
      addNewFeasibilityRow();
      populateFeasibilityTable();
      drawFeasibilityPlot();
    }

    // ===============================================================
    // The Plotting Functions (DO NOT MODIFY ANYTHING BELOW!)
    // ===============================================================
    let originalWidth, originalHeight;
    let didStoreOriginal = false;

    function setupHiDPICanvas(canvasId) {
      const canvas = document.getElementById(canvasId);
      const ctx = canvas.getContext("2d");
      const dpr = window.devicePixelRatio || 1;
      if (!didStoreOriginal) {
        originalWidth = canvas.width;
        originalHeight = canvas.height;
        didStoreOriginal = true;
      }
      canvas.width = originalWidth * dpr;
      canvas.height = originalHeight * dpr;
      canvas.style.width = originalWidth + "px";
      canvas.style.height = originalHeight + "px";
      ctx.scale(dpr, dpr);
      return ctx;
    }

    function projectPointToLine(px, py, x1, y1, x2, y2) {
      const ABx = x2 - x1;
      const ABy = y2 - y1;
      const APx = px - x1;
      const APy = py - y1;
      const ab2 = ABx * ABx + ABy * ABy;
      if (ab2 < 1e-10) return [x1, y1];
      const t = (APx * ABx + APy * ABy) / ab2;
      return [x1 + t * ABx, y1 + t * ABy];
    }

    function drawAxisTicks(ctx, minVal, maxVal, step, scaleFunc, constantFunc, axis = "x") {
        ctx.save();
        ctx.fillStyle = "#000";
        ctx.font = "12px sans-serif";
        let v = minVal;
        while (v <= maxVal + 1e-9) {
            const valStr = (Math.abs(v) < 1e-6) ? "0" : v.toFixed(2).replace(/\.?0+$/, "");
            if (axis === "x") {
              const x = scaleFunc(v);
              const y0 = constantFunc();
              ctx.beginPath();
              ctx.moveTo(x, y0);
              ctx.lineTo(x, y0 + 5);
              ctx.stroke();
              ctx.textAlign = "center";
              ctx.textBaseline = "top";
              ctx.fillText(valStr, x, y0 + 5);
            } else {
              const y = scaleFunc(v);
              const x0 = constantFunc();
              ctx.save();
              ctx.translate(x0 - 8, y);
              ctx.rotate(-Math.PI / 2);
              ctx.textAlign = "right";
              ctx.textBaseline = "middle";
              ctx.fillText(valStr, 0, 0);
              ctx.restore();
            }
            v += step;
        }
        ctx.restore();
    }

    // -------------------------
    // Draw Efficiency Plot
    // -------------------------
    function drawEfficiencyPlot() {
      const ctx = setupHiDPICanvas("efficiencyCanvas");
      const canvas = document.getElementById("efficiencyCanvas");
      const dpr = window.devicePixelRatio || 1;
      const W = canvas.width / dpr;
      const H = canvas.height / dpr;
      ctx.clearRect(0, 0, W, H);
      const pad = 60;
      const innerPad = 20;
      const minSDFdata = Math.min(...efficiencyData.map(d => d.sdf));
      const maxSDFdata = Math.max(...efficiencyData.map(d => d.sdf));
      const minSDF = Math.min(0.0, minSDFdata);
      const maxSDF = (maxSDFdata > 0.2 ? maxSDFdata : 0.2) * 1.05;
      const minPIRdata = Math.min(...efficiencyData.map(d => d.pir));
      let maxPIR = Math.max(...efficiencyData.map(d => d.pir));
      const minPIR = minPIRdata * 0.95;
      maxPIR = (maxPIR > 1.75 ? maxPIR : 1.75) * 1.05 + 0.01;
      const xScale = val => pad + ((val - minSDF) / (maxSDF - minSDF)) * (W - 2 * pad);
      const yScale = val => (H - pad) - ((val - minPIR) / (maxPIR - minPIR)) * (H - 2 * pad);

      ctx.beginPath();
      ctx.moveTo(pad, H - pad);
      ctx.lineTo(W - pad, H - pad);
      ctx.moveTo(pad, H - pad);
      ctx.lineTo(pad, pad);
      ctx.strokeStyle = "#333";
      ctx.lineWidth = 2;
      ctx.stroke();

      ctx.save();
      ctx.font = "12px sans-serif";
      ctx.fillStyle = "#000";
      for (let v = minSDF; v <= maxSDF; v += 0.05) {
        const x = xScale(v);
        const y0 = yScale(minPIR);
        ctx.beginPath();
        ctx.moveTo(x, y0);
        ctx.lineTo(x, y0 + 5);
        ctx.stroke();
        ctx.fillText(v.toFixed(2).replace(/\.?0+$/, ""), x, y0 + 15);
      }
      ctx.restore();

      ctx.save();
      ctx.font = "12px sans-serif";
      ctx.fillStyle = "#000";
      for (let v = minPIR; v <= maxPIR; v += 0.1) {
        const y = yScale(v);
        const x0 = xScale(minSDF);
        ctx.beginPath();
        ctx.moveTo(x0, y);
        ctx.lineTo(x0 - 5, y);
        ctx.stroke();
        ctx.textAlign = "right";
        ctx.textBaseline = "middle";
        ctx.fillText(v.toFixed(2).replace(/\.?0+$/, ""), x0 - 8, y);
      }
      ctx.restore();

      ctx.save();
      ctx.fillStyle = "#000";
      ctx.font = "16px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("Selected Dataset Fraction (SDF)", W / 2, H - 20);
      ctx.translate(20, H / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText("Performance Improvement Ratio (PIR)", 0, 0);
      ctx.restore();

      const A = efficiencyData.find(d => d.method === "Instruction-Mining");
      const B = efficiencyData.find(d => d.method === "InstructionGPT-4");
      let canDrawBaseline = (A && B);
      let X1, Y1, X2, Y2;
      if (canDrawBaseline) {
        const dx = B.sdf - A.sdf;
        if (Math.abs(dx) < 1e-12) canDrawBaseline = false;
      }
      if (canDrawBaseline) {
        const slope = (B.pir - A.pir) / (B.sdf - A.sdf);
        const colorRectLeft = pad + innerPad;
        const colorRectRight = W - pad - innerPad;
        const colorRectTop = pad + innerPad;
        const colorRectBottom = H - pad - innerPad;
        const leftSDF = minSDF + ((colorRectLeft - pad) / (W - 2 * pad)) * (maxSDF - minSDF);
        const rightSDF = minSDF + ((colorRectRight - pad) / (W - 2 * pad)) * (maxSDF - minSDF);
        const yAtLeft = A.pir + slope * (leftSDF - A.sdf);
        const yAtRight = A.pir + slope * (rightSDF - A.sdf);
        X1 = colorRectLeft;
        Y1 = yScale(yAtLeft);
        X2 = colorRectRight;
        Y2 = yScale(yAtRight);
        ctx.save();
        ctx.fillStyle = "#e8fff7";
        ctx.fillRect(colorRectLeft, colorRectTop, colorRectRight - colorRectLeft, colorRectBottom - colorRectTop);
        ctx.restore();
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(X1, Y1);
        ctx.lineTo(X2, Y2);
        ctx.lineTo(X2, colorRectBottom);
        ctx.lineTo(X1, colorRectBottom);
        ctx.closePath();
        ctx.fillStyle = "#f6dfdf";
        ctx.fill();
        ctx.restore();
        ctx.save();
        ctx.setLineDash([13, 5]);
        ctx.strokeStyle = "orange";
        ctx.lineWidth = 3.5;
        ctx.beginPath();
        ctx.moveTo(X1, Y1);
        ctx.lineTo(X2, Y2);
        ctx.stroke();
        ctx.restore();
      } else {
        ctx.save();
        const colorRectLeft = pad + innerPad;
        const colorRectRight = W - pad - innerPad;
        const colorRectTop = pad + innerPad;
        const colorRectBottom = H - pad - innerPad;
        ctx.fillStyle = "#e8fff7";
        ctx.fillRect(colorRectLeft, colorRectTop, colorRectRight - colorRectLeft, colorRectBottom - colorRectTop);
        ctx.restore();
      }

      const usedLabels = [];
      function placeLabel(px, py, text) {
        let labelY = py + 10;
        while (usedLabels.some(([ux, uy]) => Math.abs(uy - labelY) < 10 && Math.abs(ux - px) < 20)) {
          labelY += 12;
        }
        usedLabels.push([px, labelY]);
        ctx.fillText(text, px + 4, labelY);
      }
      efficiencyData.forEach(d => {
        const px = xScale(d.sdf);
        const py = yScale(d.pir);
        if (canDrawBaseline) {
          const [fx, fy] = projectPointToLine(px, py, X1, Y1, X2, Y2);
          const colorLine = (py < fy) ? "green" : "red";
          ctx.save();
          ctx.setLineDash([13, 3, 2, 3]);
          ctx.strokeStyle = colorLine;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(px, py);
          ctx.lineTo(fx, fy);
          ctx.stroke();
          ctx.restore();
        }
        ctx.save();
        ctx.fillStyle = "#1f77b4";
        ctx.beginPath();
        ctx.moveTo(px, py + 5);
        ctx.lineTo(px - 5, py - 4);
        ctx.lineTo(px + 5, py - 4);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
        ctx.save();
        ctx.font = "14px sans-serif";
        ctx.fillStyle = "#000";
        ctx.textAlign = "left";
        placeLabel(px, py, d.method);
        ctx.restore();
      });
    }

    // -------------------------
    // Draw Feasibility Plot
    // -------------------------
    function drawFeasibilityPlot() {
      const ctx = setupHiDPICanvas("feasibilityCanvas");
      const canvas = document.getElementById("feasibilityCanvas");
      const size = Math.min(canvas.width, canvas.height) / (window.devicePixelRatio || 1);
      const W = size, H = size;
      ctx.clearRect(0, 0, W, H);
      const pad = 60;
      // Modified: use simplicityRank and flexibilityRank instead of simplicity and flexibility.
      const maxVal = Math.max(
        Math.max(...feasibilityData.map(d => (typeof d.simplicityRank === "number" ? d.simplicityRank : 0))),
        Math.max(...feasibilityData.map(d => (typeof d.flexibilityRank === "number" ? d.flexibilityRank : 0)))
      ) + 1;
      const xScale = v => pad + (v - 0) / (maxVal - 0) * (W - 2 * pad);
      const yScale = v => (H - pad) - (v - 0) / (maxVal - 0) * (H - 2 * pad);
      const usedLabels = [];
      function placeLabel(px, py, text) {
        let labelY = py + 14;
        while (usedLabels.some(([ux, uy]) => Math.abs(uy - labelY) < 10 && Math.abs(ux - px) < 80)) {
          labelY += 14;
        }
        usedLabels.push([px, labelY]);
        ctx.fillText(text, px + 4, labelY);
      }
      ctx.beginPath();
      ctx.moveTo(pad, H - pad);
      ctx.lineTo(W - pad, H - pad);
      ctx.moveTo(pad, H - pad);
      ctx.lineTo(pad, pad);
      ctx.strokeStyle = "#333";
      ctx.lineWidth = 2;
      ctx.stroke();
      function drawFeasTicks() {
        ctx.save();
        ctx.font = "12px sans-serif";
        ctx.fillStyle = "#000";
        for (let v = 0; v <= maxVal; v++) {
          const x = xScale(v), y0 = yScale(0);
          ctx.beginPath();
          ctx.moveTo(x, y0);
          ctx.lineTo(x, y0 + 5);
          ctx.stroke();
          ctx.fillText(v.toString(), x, y0 + 15);
          const y = yScale(v), x0 = xScale(0);
          ctx.beginPath();
          ctx.moveTo(x0, y);
          ctx.lineTo(x0 - 5, y);
          ctx.stroke();
          ctx.textAlign = "right";
          ctx.textBaseline = "middle";
          ctx.fillText(v.toString(), x0 - 8, y);
        }
        ctx.restore();
      }
      drawFeasTicks();
      ctx.save();
      ctx.fillStyle = "#000";
      ctx.font = "16px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("Simplicity Rank", W / 2, H - 20);
      ctx.translate(20, H / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText("Flexibility Rank", 0, 0);
      ctx.restore();
      const x0 = xScale(0), y0 = yScale(0);
      const xMax = xScale(maxVal - 0.5), yMax = yScale(maxVal - 0.5);
      ctx.save();
      ctx.strokeStyle = "orange";
      ctx.lineWidth = 3;
      ctx.setLineDash([]);
      ctx.beginPath();
      ctx.moveTo(x0, y0);
      ctx.lineTo(xMax, yMax);
      ctx.stroke();
      ctx.restore();
      feasibilityData.forEach(d => {
        if (typeof d.simplicityRank !== "number" || typeof d.flexibilityRank !== "number") return;
        const sx = xScale(d.simplicityRank);
        const sy = yScale(d.flexibilityRank);
        const [px, py] = projectPointToLine(sx, sy, x0, y0, xMax, yMax);
        ctx.save();
        ctx.setLineDash([3, 3]);
        ctx.strokeStyle = "green";
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(sx, sy);
        ctx.lineTo(px, py);
        ctx.stroke();
        ctx.restore();
        ctx.save();
        ctx.strokeStyle = "#1f77b4";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(sx, sy, 5, 0, 2 * Math.PI);
        ctx.stroke();
        ctx.restore();
        ctx.save();
        ctx.fillStyle = "green";
        ctx.beginPath();
        ctx.arc(px, py, 5, 0, 2 * Math.PI);
        ctx.fill();
        ctx.restore();
        ctx.save();
        ctx.font = "14px sans-serif";
        ctx.fillStyle = "#000";
        ctx.textAlign = "left";
        // Modified: label with final feasibility rank
        ctx.fillText(d.feasibilityRank, px - 10, py - 6);
        ctx.restore();
        ctx.save();
        ctx.font = "14px sans-serif";
        ctx.fillStyle = "#000";
        ctx.textAlign = "left";
        placeLabel(sx, sy, d.method);
        ctx.restore();
      });
    }


    // ===============================================================
    // Master update and Save functions
    // ===============================================================
    // Use separate update buttons.
    window.onload = () => {
      populateEfficiencyTable();
      populateFeasibilityTable();
      drawEfficiencyPlot();
      drawFeasibilityPlot();
      document.getElementById("updateEfficiencyBtn").addEventListener("click", updateEfficiency);
      document.getElementById("updateFeasibilityBtn").addEventListener("click", updateFeasibility);
      document.getElementById("saveBtn").addEventListener("click", saveDataAndPlots);
    };

    function saveDataAndPlots() {
      const dataObj = { efficiencyData, feasibilityData };
      const dataStr = JSON.stringify(dataObj, null, 2);
      const blob = new Blob([dataStr], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.download = "leaderboard_data.json";
      link.click();
      URL.revokeObjectURL(url);
      function downloadCanvas(id, filename) {
        const c = document.getElementById(id);
        const a = document.createElement("a");
        a.href = c.toDataURL("image/png");
        a.download = filename;
        a.click();
      }
      downloadCanvas("efficiencyCanvas", "efficiency_plot.png");
      downloadCanvas("feasibilityCanvas", "feasibility_plot.png");
    }
  </script>

  <!-- Add this right before the closing </body> tag in index.html -->
  <footer style="margin-top: 2rem; padding: 1rem; text-align: center; color: #666; border-top: 1px solid #eee; font-size: 0.9rem;">
    <p>
      Acknowledgements: Special thanks to Rui Ke for providing the core PIR calculator code. 
      We also appreciate the valuable suggestions and advice from the research community.
    </p>
  </footer>
</body>
</html>
