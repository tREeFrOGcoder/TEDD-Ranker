<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Minimalism Leaderboard</title>
  <link rel="stylesheet" href="style.css" />
  <style>
    /* New inline styles for dynamic input feedback */
    .disabled {
      background-color: #e0e0e0;
      pointer-events: none;
    }
    .error {
      color: red;
      font-size: 12px;
    }
    /* Simple styling for update buttons in each section */
    .section-update-btn {
      margin-top: 10px;
      margin-bottom: 10px;
    }
  </style>
</head>
<body>
  <h1>Minimalism Leaderboard</h1>

  <!-- ===== Efficiency Section ===== -->
  <div class="section-container" id="efficiencySection">
    <h2>Efficiency Indicators</h2>
    <!-- Efficiency Input Fields (moved above the table) -->
    <div class="input-container">
      <div>
        <label for="effMethodNames">Method Name:</label>
        <input type="text" id="effMethodNames" placeholder="e.g. AlpaGasus_demo" />
      </div>
      <div>
        <label for="pirType">PIR Type:</label>
        <select id="pirType">
          <option value="same_win_rate">Same Win Rate</option>
          <option value="same_benchmark">Same Benchmark</option>
          <option value="other_benchmark">Other Benchmark</option>
        </select>
      </div>
      <div>
        <label for="SEM">SEM values:</label>
        <input type="text" id="SEM" placeholder="can use multiple values, e.g. 1.2, 1.4" />
        <div id="semError" class="error"></div>
      </div>
      <div>
        <label for="BM">BM values:</label>
        <input type="text" id="BM" placeholder="can use multiple values, e.g. 1.0, 1.0" />
        <div id="bmError" class="error"></div>
      </div>
      <!-- New PIR input field for direct PIR value -->
      <div>
        <label for="PIR">PIR value:</label>
        <input type="text" id="PIR" placeholder="direct PIR value, e.g. 0.95" />
        <div id="pirError" class="error"></div>
      </div>
      <div>
        <label for="SDF">SDF values:</label>
        <input type="text" id="SDF" placeholder="one optimal value, e.g. 0.125" />
      </div>
    </div>
    <!-- NEW: Separate Update Efficiency Button -->
    <div class="section-update-btn">
      <button id="updateEfficiencyBtn">Update Efficiency</button>
    </div>

    <!-- Efficiency Table & Plot in one row -->
    <div class="row-container">
      <div class="half">
        <div class="table-container">
          <table id="efficiencyTable" class="leaderboard-table">
            <thead>
              <tr>
                <th>Method</th>
                
                <th>Performance Improvement Ratio (PIR)</th>
                <th>Selected Dataset Fraction (SDF)</th>
                <th>Actions</th> <!-- NEW column for delete buttons -->
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>
      <div class="half">
        <div class="plot-container">
          <canvas id="efficiencyCanvas" width="700" height="500"></canvas>
        </div>
      </div>
    </div>
  </div>

  <!-- ===== Feasibility Section ===== -->
  <div class="section-container" id="feasibilitySection">
    <h2>Feasibility Indicators</h2>
    <!-- NEW: Separate Update Feasibility Button -->
    <div class="section-update-btn">
      <button id="updateFeasibilityBtn">Update Feasibility</button>
    </div>
    <!-- Feasibility Table & Plot in one row -->
    <div class="row-container">
      <div class="half">
        <div class="table-container">
          <table id="feasibilityTable" class="leaderboard-table">
            <thead>
              <tr>
                <th>Method</th>
                <th># Trained LLMs</th>
                <th># Algorithm Steps (Using LLMs)</th>
                <th>Rep.</th>
                <th>Model Free</th>
                <th>Dataset Free</th>
                <th>ChatGPT Free</th>
                <th>Simplicity</th>
                <th>Flexibility</th>
                <th>Feasibility</th>
              </tr>
            </thead>
            <tbody></tbody>
            <tfoot>
              <tr>
                <td><input type="text" id="newFeasMethod" placeholder="Method Name" /></td>
                <td><input type="text" id="newFeasLLM" placeholder="#LLMs" /></td>
                <td><input type="text" id="newFeasSteps" placeholder="#Steps(LLMs)" /></td>
                <td>
                  <select id="newFeasRep">
                    <option value="true">&#10004;</option>
                    <option value="false">&#10007;</option>
                  </select>
                </td>
                <td>
                  <select id="newFeasModelFree">
                    <option value="true">&#10004;</option>
                    <option value="false">&#10007;</option>
                  </select>
                </td>
                <td>
                  <select id="newFeasDataFree">
                    <option value="true">&#10004;</option>
                    <option value="false">&#10007;</option>
                  </select>
                </td>
                <td>
                  <select id="newFeasChatFree">
                    <option value="true">&#10004;</option>
                    <option value="false">&#10007;</option>
                  </select>
                </td>
                <td>Auto</td>
                <td>Auto</td>
                <td><input type="number" step="1" id="newFeasFeas" placeholder="Feas." /></td>
              </tr>
            </tfoot>
          </table>
        </div>
      </div>
      <div class="half">
        <div class="plot-container">
          <canvas id="feasibilityCanvas" width="700" height="500"></canvas>
        </div>
      </div>
    </div>
  </div>

  <!-- Bottom Save Button (unchanged) -->
  <div class="button-container">
    <button id="saveBtn">Save Data &amp; Plots</button>
  </div>

  <script>
    // ===============================================================
    // Efficiency Calculation Functions (Updated for new input interactions)
    // ===============================================================
    // Global efficiencyData (default data)
    let efficiencyData = [
      { method: "AlpaGasus", sdf: 0.17, pir: 1.284 },
      { method: "Superfiltering", sdf: 0.05, pir: 1.475 },
      { method: "InsTag", sdf: 0.0196, pir: 1.344 },
      { method: "DEITA", sdf: 0.1, pir: 1.426 },
      { method: "InstructionGPT-4", sdf: 0.06, pir: 1.443 },
      { method: "Nuggets", sdf: 0.15, pir: 1.519 },
      { method: "IFD", sdf: 0.05, pir: 1.747 },
      { method: "LESS", sdf: 0.05, pir: 1.491 },
      { method: "Instruction-Mining", sdf: 0.025, pir: 1.400 },
      { method: "SHED", sdf: 0.09, pir: 1.460 },
      { method: "CaR", sdf: 0.0196, pir: 1.343 },
      { method: "SelectIT", sdf: 0.2, pir: 1.653 }
    ];
    // --- NEW: assign a global order to each work for tie-breaking ---
    let nextEfficiencyOrder = 1;
    efficiencyData.forEach(d => { d.order = nextEfficiencyOrder++; });

    function linearTransform(x, x_vals, y_vals) {
      let x1 = x_vals[0], x2 = x_vals[1];
      let y1 = y_vals[0], y2 = y_vals[1];
      let m = (y2 - y1) / (x2 - x1);
      let b = y1 - m * x1;
      return m * x + b;
    }

    function transform(sameBenchPir = 0, othBenchPir = 0) {
      if (sameBenchPir !== 0) {
        return linearTransform(sameBenchPir, [0.949, 1.01], [1.284, 1.475]);
      } else if (othBenchPir !== 0) {
        return linearTransform(othBenchPir, [0.985, 1.000], [1.344, 1.426]);
      }
      return null;
    }

    // Updated getPIR: supports either a direct PIR input OR calculation from SEM/BM.
    // Also supports two valid input cases: (a) multiple SEM with a single BM (broadcast) or (b) paired SEM and BM.
    function getPIR(type, SEM = null, BM = null, pir = null) {
      let PIR;
      if (pir !== null) {
        // Direct PIR input provided.
        PIR = pir;
      } else if (SEM !== null && BM !== null) {
        if (BM.length === 1 && SEM.length >= 1) {
          let pirArray = SEM.map(sem => sem / BM[0]);
          pir = pirArray.reduce((acc, val) => acc + val, 0) / pirArray.length;
        } else if (SEM.length === BM.length) {
          let pirArray = SEM.map((sem, i) => sem / BM[i]);
          pir = pirArray.reduce((acc, val) => acc + val, 0) / pirArray.length;
        } else {
          return { error: "Invalid input: Provide either one BM value with one or more SEM values, or equal-length arrays of SEM and BM values." };
        }
        if (type === "same_win_rate") {
          PIR = pir;
        } else if (type === "same_benchmark") {
          PIR = transform(pir, 0);
        } else if (type === "other_benchmark") {
          PIR = transform(0, pir);
        }
      }
      return { result: PIR };
    }

    // --- Dynamic Input State Updates for Efficiency Section ---
    function updateEfficiencyInputStates() {
      const semInput = document.getElementById("SEM");
      const bmInput = document.getElementById("BM");
      const pirInput = document.getElementById("PIR");

      // If SEM or BM have input, disable PIR.
      if (semInput.value.trim() !== "" || bmInput.value.trim() !== "") {
        pirInput.disabled = true;
        pirInput.classList.add("disabled");
      } else {
        pirInput.disabled = false;
        pirInput.classList.remove("disabled");
      }

      // If PIR has input, disable SEM and BM.
      if (pirInput.value.trim() !== "") {
        semInput.disabled = true;
        bmInput.disabled = true;
        semInput.classList.add("disabled");
        bmInput.classList.add("disabled");
      } else {
        semInput.disabled = false;
        bmInput.disabled = false;
        semInput.classList.remove("disabled");
        bmInput.classList.remove("disabled");
      }
    }

    // Add event listeners to update input states dynamically.
    document.getElementById("SEM").addEventListener("input", updateEfficiencyInputStates);
    document.getElementById("BM").addEventListener("input", updateEfficiencyInputStates);
    document.getElementById("PIR").addEventListener("input", updateEfficiencyInputStates);

    // --- NEW: Function to compute signed efficiency values and sort the efficiencyData array ---
    function sortEfficiencyData() {
      const canvas = document.getElementById("efficiencyCanvas");
      if (!canvas) return;
      const dpr = window.devicePixelRatio || 1;
      const W = canvas.width / dpr;
      const H = canvas.height / dpr;
      const pad = 60;
      const innerPad = 20;
      const minSDFdata = Math.min(...efficiencyData.map(d => d.sdf));
      const maxSDFdata = Math.max(...efficiencyData.map(d => d.sdf));
      const minSDF = Math.min(0.0, minSDFdata);
      const maxSDF = (maxSDFdata > 0.2 ? maxSDFdata : 0.2) * 1.05;
      const minPIRdata = Math.min(...efficiencyData.map(d => d.pir));
      let maxPIR = Math.max(...efficiencyData.map(d => d.pir));
      const minPIR = minPIRdata * 0.95;
      maxPIR = (maxPIR > 1.75 ? maxPIR : 1.75) * 1.05 + 0.01;
      const xScale = val => pad + ((val - minSDF) / (maxSDF - minSDF)) * (W - 2 * pad);
      const yScale = val => (H - pad) - ((val - minPIR) / (maxPIR - minPIR)) * (H - 2 * pad);

      const A = efficiencyData.find(d => d.method === "Instruction-Mining");
      const B = efficiencyData.find(d => d.method === "InstructionGPT-4");
      if (!A || !B) return;
      const dx = B.sdf - A.sdf;
      if (Math.abs(dx) < 1e-12) return;
      const slope = (B.pir - A.pir) / (B.sdf - A.sdf);
      const colorRectLeft = pad + innerPad;
      const colorRectRight = W - pad - innerPad;
      const leftSDF = minSDF + ((colorRectLeft - pad) / (W - 2 * pad)) * (maxSDF - minSDF);
      const rightSDF = minSDF + ((colorRectRight - pad) / (W - 2 * pad)) * (maxSDF - minSDF);
      const yAtLeft = A.pir + slope * (leftSDF - A.sdf);
      const yAtRight = A.pir + slope * (rightSDF - A.sdf);
      const X1 = colorRectLeft;
      const Y1 = yScale(yAtLeft);
      const X2 = colorRectRight;
      const Y2 = yScale(yAtRight);

      // Normal vector of baseline: n = (-(Y2 - Y1), X2 - X1) normalized
      const dxBase = X2 - X1;
      const dyBase = Y2 - Y1;
      const norm = Math.sqrt(dxBase * dxBase + dyBase * dyBase);
      const nx = -dyBase / norm;
      const ny = dxBase / norm;

      efficiencyData.forEach(d => {
        const px = xScale(d.sdf);
        const py = yScale(d.pir);
        const proj = projectPointToLine(px, py, X1, Y1, X2, Y2);
        const dxProj = px - proj[0];
        const dyProj = py - proj[1];
        const distance = Math.sqrt(dxProj * dxProj + dyProj * dyProj);
        const dot = dxProj * nx + dyProj * ny;
        const sign = (dot >= 0) ? 1 : -1;
        d.effVal = sign * distance;
      });

      // Sort: descending by effVal, then alphabetically by method name, then by order (old first)
      efficiencyData.sort((a, b) => {
        if (a.effVal !== b.effVal) {
          return a.effVal - b.effVal;
        }
        if (a.method.toLowerCase() < b.method.toLowerCase()) return -1;
        if (a.method.toLowerCase() > b.method.toLowerCase()) return 1;
        return a.order - b.order;
      });
    }

    // --- Modified Efficiency Table Update Function ---
    function populateEfficiencyTable() {
      const effTbody = document.querySelector("#efficiencyTable tbody");
      effTbody.innerHTML = "";
      const SEMInput = document.getElementById("SEM").value.trim();
      const BMInput = document.getElementById("BM").value.trim();
      const PIRInputVal = document.getElementById("PIR").value.trim();
      const SDFInput = document.getElementById("SDF").value.trim();

      // If new efficiency input is provided, update the global efficiencyData array.
      if (SDFInput !== "") {
        if (SEMInput !== "" || BMInput !== "" || PIRInputVal !== "") {
          const methodNamesInput = document.getElementById("effMethodNames").value.trim();
          const methods = methodNamesInput ? methodNamesInput.split(",").map(s => s.trim()) : [];
          const pirType = document.getElementById("pirType").value;
          const SEM = SEMInput ? SEMInput.split(",").map(Number) : [];
          const BM = BMInput ? BMInput.split(",").map(Number) : [];
          const SDF = SDFInput.split(",").map(Number);

          if (PIRInputVal === "" && ((SEM.length > 0 || BM.length > 0) && (SEM.length !== BM.length && BM.length !== 1))) {
            document.getElementById("semError").textContent = "SEM and BM must have the same number of values or BM must be a single value.";
            document.getElementById("bmError").textContent = "SEM and BM must have the same number of values or BM must be a single value.";
            return;
          } else {
            document.getElementById("semError").textContent = "";
            document.getElementById("bmError").textContent = "";
          }

          let pirValue;
          if (PIRInputVal !== "") {
            pirValue = parseFloat(PIRInputVal);
          } else {
            const result = getPIR(pirType, SEM, BM, null);
            if (result.error) {
              alert(result.error);
              return;
            }
            pirValue = result.result;
          }

          // Append new entries (one for each SDF value) with an order property.
          for (let i = 0; i < SDF.length; i++) {
            const methodName = methods[i] ? methods[i] : "Method " + (efficiencyData.length + 1);
            efficiencyData.push({
              method: methodName,
              sdf: SDF[i],
              pir: pirValue,
              order: nextEfficiencyOrder++
            });
          }

          // Clear the input fields after adding.
          document.getElementById("effMethodNames").value = "";
          document.getElementById("SEM").value = "";
          document.getElementById("BM").value = "";
          
          document.getElementById("PIR").value = "";
          document.getElementById("SDF").value = "";
          updateEfficiencyInputStates();
        }
      }

      // --- NEW: Sort the efficiencyData array based on computed efficiency values ---
      sortEfficiencyData();

      // Re-populate table from the entire efficiencyData array.
      efficiencyData.forEach(d => {
        const tr = document.createElement("tr");
        let deleteButtonHTML = "";
        // Only allow deletion for non-baseline methods.
        if (d.method !== "Instruction-Mining" && d.method !== "InstructionGPT-4") {
          deleteButtonHTML = `<button class="deleteBtn" data-method="${d.method}" data-order="${d.order}">Delete</button>`;
        }
        tr.innerHTML = `<td>${d.method}</td>
                        
                        <td>${(typeof d.pir === "number") ? d.pir.toFixed(4) : d.pir}</td>
                        <td>${d.sdf}</td>
                        <td>${deleteButtonHTML}</td>`;
        effTbody.appendChild(tr);
      });

      // Attach event listeners to delete buttons.
      document.querySelectorAll(".deleteBtn").forEach(btn => {
        btn.addEventListener("click", function() {
          const methodToDelete = this.getAttribute("data-method");
          const orderToDelete = parseInt(this.getAttribute("data-order"));
          efficiencyData = efficiencyData.filter(d => {
            // Match both method and order to ensure uniqueness.
            return !(d.method === methodToDelete && d.order === orderToDelete);
          });
          populateEfficiencyTable();
          drawEfficiencyPlot();
        });
      });
    }

    // Separate update functions for Efficiency and Feasibility.
    function updateEfficiency() {
      populateEfficiencyTable();
      drawEfficiencyPlot();
    }

    function updateFeasibility() {
      addNewFeasibilityRow();
      populateFeasibilityTable();
      drawFeasibilityPlot();
    }

    // ===============================================================
    // Feasibility Data and Table (Input and Auto-calculated Columns)
    // ===============================================================
    const feasibilityData = [
      {
        method: "AlpaGasus",
        llmCount: "0",
        steps: "2(1)",
        rep: false,
        simplicity: 1,
        modelFree: true,
        datasetFree: true,
        chatGPTFree: false,
        flexibility: 1,
        feasibility: 1
      },
      {
        method: "InsTag",
        llmCount: "0",
        steps: "3(1)",
        rep: false,
        simplicity: 1,
        modelFree: true,
        datasetFree: true,
        chatGPTFree: false,
        flexibility: 1,
        feasibility: 2
      },
      {
        method: "CaR",
        llmCount: "0",
        steps: "4(0)",
        rep: true,
        simplicity: 2,
        modelFree: true,
        datasetFree: true,
        chatGPTFree: false,
        flexibility: 2,
        feasibility: 3
      },
      {
        method: "Nuggets",
        llmCount: "0",
        steps: "4(2)",
        rep: true,
        simplicity: 2,
        modelFree: true,
        datasetFree: true,
        chatGPTFree: false,
        flexibility: 2,
        feasibility: 3
      },
      {
        method: "SelectIT",
        llmCount: "0",
        steps: "4(3)",
        rep: true,
        simplicity: 2,
        modelFree: true,
        datasetFree: true,
        chatGPTFree: false,
        flexibility: 2,
        feasibility: 3
      },
      {
        method: "Superfiltering",
        llmCount: "1*",
        steps: "3(1*)",
        rep: true,
        simplicity: 3,
        modelFree: true,
        datasetFree: true,
        chatGPTFree: false,
        flexibility: 4,
        feasibility: 4
      },
      {
        method: "IFD",
        llmCount: "1",
        steps: "3(1)",
        rep: false,
        simplicity: 4,
        modelFree: false,
        datasetFree: false,
        chatGPTFree: false,
        flexibility: 3,
        feasibility: 5
      },
      {
        method: "LESS",
        llmCount: "1",
        steps: "4(2)",
        rep: true,
        simplicity: 5,
        modelFree: false,
        datasetFree: false,
        chatGPTFree: false,
        flexibility: 3,
        feasibility: 6
      },
      {
        method: "DEITA",
        llmCount: "2",
        steps: "5(4)",
        rep: true,
        simplicity: 6,
        modelFree: false,
        datasetFree: false,
        chatGPTFree: true,
        flexibility: 3,
        feasibility: 7
      },
      {
        method: "InstructionGPT-4",
        llmCount: "30",
        steps: "4(1)",
        rep: false,
        simplicity: 7,
        modelFree: false,
        datasetFree: false,
        chatGPTFree: false,
        flexibility: 4,
        feasibility: 7
      },
      {
        method: "SHED",
        llmCount: "500",
        steps: "3(0)",
        rep: true,
        simplicity: 8,
        modelFree: false,
        datasetFree: false,
        chatGPTFree: true,
        flexibility: 3,
        feasibility: 7
      },
      {
        method: "Instruction-Mining",
        llmCount: "129",
        steps: "4(0)",
        rep: false,
        simplicity: 8,
        modelFree: true,
        datasetFree: true,
        chatGPTFree: false,
        flexibility: 4,
        feasibility: 8
      }
    ];

    function populateFeasibilityTable() {
      const feasTbody = document.querySelector("#feasibilityTable tbody");
      feasTbody.innerHTML = "";
      feasibilityData.forEach(d => {
        const repVal = d.rep ? "&#10004;" : "&#10007;";
        const mfVal  = d.modelFree   ? "&#10004;" : "&#10007;";
        const dfVal  = d.datasetFree ? "&#10004;" : "&#10007;";
        const cfVal  = d.chatGPTFree ? "&#10004;" : "&#10007;";
        const tr = document.createElement("tr");
        tr.innerHTML = `<td>${d.method}</td>
                        <td>${d.llmCount}</td>
                        <td>${d.steps}</td>
                        <td>${repVal}</td>
                        <td>${mfVal}</td>
                        <td>${dfVal}</td>
                        <td>${cfVal}</td>
                        <td>${d.simplicity}</td>
                        <td>${d.flexibility}</td>
                        <td>${d.feasibility}</td>`;
        feasTbody.appendChild(tr);
      });
    }

    // Adds a new feasibility row based on tfoot inputs.
    function addNewFeasibilityRow() {
      const fm = document.getElementById("newFeasMethod").value.trim();
      const fllm = document.getElementById("newFeasLLM").value.trim();
      const fsteps = document.getElementById("newFeasSteps").value.trim();
      const frep = document.getElementById("newFeasRep").value === "true";
      const fmf = document.getElementById("newFeasModelFree").value === "true";
      const fdf = document.getElementById("newFeasDataFree").value === "true";
      const fcf = document.getElementById("newFeasChatFree").value === "true";
      const ffeas = parseInt(document.getElementById("newFeasFeas").value);
      if (fm && fllm && fsteps && !isNaN(ffeas)) {
        const fsimp = "Auto";
        const fflex = "Auto";
        feasibilityData.push({
          method: fm,
          llmCount: fllm,
          steps: fsteps,
          rep: frep,
          simplicity: fsimp,
          modelFree: fmf,
          datasetFree: fdf,
          chatGPTFree: fcf,
          flexibility: fflex,
          feasibility: ffeas
        });
      }
    }

    // ===============================================================
    // The Plotting Functions (DO NOT MODIFY ANYTHING BELOW!)
    // ===============================================================
    let originalWidth, originalHeight;
    let didStoreOriginal = false;

    function setupHiDPICanvas(canvasId) {
      const canvas = document.getElementById(canvasId);
      const ctx = canvas.getContext("2d");
      const dpr = window.devicePixelRatio || 1;
      if (!didStoreOriginal) {
        originalWidth = canvas.width;
        originalHeight = canvas.height;
        didStoreOriginal = true;
      }
      canvas.width = originalWidth * dpr;
      canvas.height = originalHeight * dpr;
      canvas.style.width = originalWidth + "px";
      canvas.style.height = originalHeight + "px";
      ctx.scale(dpr, dpr);
      return ctx;
    }

    function projectPointToLine(px, py, x1, y1, x2, y2) {
      const ABx = x2 - x1;
      const ABy = y2 - y1;
      const APx = px - x1;
      const APy = py - y1;
      const ab2 = ABx * ABx + ABy * ABy;
      if (ab2 < 1e-10) return [x1, y1];
      const t = (APx * ABx + APy * ABy) / ab2;
      return [x1 + t * ABx, y1 + t * ABy];
    }

    function drawAxisTicks(ctx, minVal, maxVal, step, scaleFunc, constantFunc, axis = "x") {
        ctx.save();
        ctx.fillStyle = "#000";
        ctx.font = "12px sans-serif";
        let v = minVal;
        while (v <= maxVal + 1e-9) {
            const valStr = (Math.abs(v) < 1e-6) ? "0" : v.toFixed(2).replace(/\.?0+$/, "");
            if (axis === "x") {
              const x = scaleFunc(v);
              const y0 = constantFunc();
              ctx.beginPath();
              ctx.moveTo(x, y0);
              ctx.lineTo(x, y0 + 5);
              ctx.stroke();
              ctx.textAlign = "center";
              ctx.textBaseline = "top";
              ctx.fillText(valStr, x, y0 + 5);
            } else {
              const y = scaleFunc(v);
              const x0 = constantFunc();
              ctx.save();
              ctx.translate(x0 - 8, y);
              ctx.rotate(-Math.PI / 2);
              ctx.textAlign = "right";
              ctx.textBaseline = "middle";
              ctx.fillText(valStr, 0, 0);
              ctx.restore();
            }
            v += step;
        }
        ctx.restore();
    }

    // -------------------------
    // Draw Efficiency Plot
    // -------------------------
    function drawEfficiencyPlot() {
      const ctx = setupHiDPICanvas("efficiencyCanvas");
      const canvas = document.getElementById("efficiencyCanvas");
      const dpr = window.devicePixelRatio || 1;
      const W = canvas.width / dpr;
      const H = canvas.height / dpr;
      ctx.clearRect(0, 0, W, H);
      const pad = 60;
      const innerPad = 20;

      const minSDFdata = Math.min(...efficiencyData.map(d => d.sdf));
      const maxSDFdata = Math.max(...efficiencyData.map(d => d.sdf));
      const minSDF = Math.min(0.0, minSDFdata);
      const maxSDF = (maxSDFdata > 0.2 ? maxSDFdata : 0.2) * 1.05;

      const minPIRdata = Math.min(...efficiencyData.map(d => d.pir));
      let maxPIR = Math.max(...efficiencyData.map(d => d.pir));
      const minPIR = minPIRdata * 0.95;
      maxPIR = (maxPIR > 1.75 ? maxPIR : 1.75) * 1.05 + 0.01;

      const xScale = val => pad + ((val - minSDF) / (maxSDF - minSDF)) * (W - 2 * pad);
      const yScale = val => (H - pad) - ((val - minPIR) / (maxPIR - minPIR)) * (H - 2 * pad);

      ctx.beginPath();
      ctx.moveTo(pad, H - pad);
      ctx.lineTo(W - pad, H - pad);
      ctx.moveTo(pad, H - pad);
      ctx.lineTo(pad, pad);
      ctx.strokeStyle = "#333";
      ctx.lineWidth = 2;
      ctx.stroke();

      ctx.save();
      ctx.font = "12px sans-serif";
      ctx.fillStyle = "#000";
      for (let v = minSDF; v <= maxSDF; v += 0.05) {
        const x = xScale(v);
        const y0 = yScale(minPIR);
        ctx.beginPath();
        ctx.moveTo(x, y0);
        ctx.lineTo(x, y0 + 5);
        ctx.stroke();
        ctx.fillText(v.toFixed(2).replace(/\.?0+$/, ""), x, y0 + 15);
      }
      ctx.restore();

      ctx.save();
      ctx.font = "12px sans-serif";
      ctx.fillStyle = "#000";
      for (let v = minPIR; v <= maxPIR; v += 0.1) {
        const y = yScale(v);
        const x0 = xScale(minSDF);
        ctx.beginPath();
        ctx.moveTo(x0, y);
        ctx.lineTo(x0 - 5, y);
        ctx.stroke();
        ctx.textAlign = "right";
        ctx.textBaseline = "middle";
        ctx.fillText(v.toFixed(2).replace(/\.?0+$/, ""), x0 - 8, y);
      }
      ctx.restore();

      ctx.save();
      ctx.fillStyle = "#000";
      ctx.font = "16px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("Selected Dataset Fraction (SDF)", W / 2, H - 20);
      ctx.translate(20, H / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText("Performance Improvement Ratio (PIR)", 0, 0);
      ctx.restore();

      const A = efficiencyData.find(d => d.method === "Instruction-Mining");
      const B = efficiencyData.find(d => d.method === "InstructionGPT-4");
      let canDrawBaseline = (A && B);
      let X1, Y1, X2, Y2;
      if (canDrawBaseline) {
        const dx = B.sdf - A.sdf;
        if (Math.abs(dx) < 1e-12) canDrawBaseline = false;
      }
      if (canDrawBaseline) {
        const slope = (B.pir - A.pir) / (B.sdf - A.sdf);
        const colorRectLeft = pad + innerPad;
        const colorRectRight = W - pad - innerPad;
        const colorRectTop = pad + innerPad;
        const colorRectBottom = H - pad - innerPad;
        const leftSDF = minSDF + ((colorRectLeft - pad) / (W - 2 * pad)) * (maxSDF - minSDF);
        const rightSDF = minSDF + ((colorRectRight - pad) / (W - 2 * pad)) * (maxSDF - minSDF);
        const yAtLeft = A.pir + slope * (leftSDF - A.sdf);
        const yAtRight = A.pir + slope * (rightSDF - A.sdf);
        X1 = colorRectLeft;
        Y1 = yScale(yAtLeft);
        X2 = colorRectRight;
        Y2 = yScale(yAtRight);
        ctx.save();
        ctx.fillStyle = "#e8fff7";
        ctx.fillRect(colorRectLeft, colorRectTop, colorRectRight - colorRectLeft, colorRectBottom - colorRectTop);
        ctx.restore();
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(X1, Y1);
        ctx.lineTo(X2, Y2);
        ctx.lineTo(X2, colorRectBottom);
        ctx.lineTo(X1, colorRectBottom);
        ctx.closePath();
        ctx.fillStyle = "#f6dfdf";
        ctx.fill();
        ctx.restore();
        ctx.save();
        ctx.setLineDash([13, 5]);
        ctx.strokeStyle = "orange";
        ctx.lineWidth = 3.5;
        ctx.beginPath();
        ctx.moveTo(X1, Y1);
        ctx.lineTo(X2, Y2);
        ctx.stroke();
        ctx.restore();
      } else {
        ctx.save();
        const colorRectLeft = pad + innerPad;
        const colorRectRight = W - pad - innerPad;
        const colorRectTop = pad + innerPad;
        const colorRectBottom = H - pad - innerPad;
        ctx.fillStyle = "#e8fff7";
        ctx.fillRect(colorRectLeft, colorRectTop, colorRectRight - colorRectLeft, colorRectBottom - colorRectTop);
        ctx.restore();
      }

      const usedLabels = [];
      function placeLabel(px, py, text) {
        let labelY = py + 10;
        while (usedLabels.some(([ux, uy]) => Math.abs(uy - labelY) < 10 && Math.abs(ux - px) < 20)) {
          labelY += 12;
        }
        usedLabels.push([px, labelY]);
        ctx.fillText(text, px + 4, labelY);
      }
      efficiencyData.forEach(d => {
        const px = xScale(d.sdf);
        const py = yScale(d.pir);
        if (canDrawBaseline) {
          const [fx, fy] = projectPointToLine(px, py, X1, Y1, X2, Y2);
          const colorLine = (py < fy) ? "green" : "red";
          ctx.save();
          ctx.setLineDash([13, 3, 2, 3]);
          ctx.strokeStyle = colorLine;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(px, py);
          ctx.lineTo(fx, fy);
          ctx.stroke();
          ctx.restore();
        }
        ctx.save();
        ctx.fillStyle = "#1f77b4";
        ctx.beginPath();
        ctx.moveTo(px, py + 5);
        ctx.lineTo(px - 5, py - 4);
        ctx.lineTo(px + 5, py - 4);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
        ctx.save();
        ctx.font = "14px sans-serif";
        ctx.fillStyle = "#000";
        ctx.textAlign = "left";
        placeLabel(px, py, d.method);
        ctx.restore();
      });
    }

    // -------------------------
    // Draw Feasibility Plot
    // -------------------------
    function drawFeasibilityPlot() {
      const ctx = setupHiDPICanvas("feasibilityCanvas");
      const canvas = document.getElementById("feasibilityCanvas");
      const size = Math.min(canvas.width, canvas.height) / (window.devicePixelRatio || 1);
      const W = size, H = size;
      ctx.clearRect(0, 0, W, H);
      const pad = 60;
      const minVal = 0;
      const maxVal = Math.max(
        Math.max(...feasibilityData.map(d => (typeof d.simplicity === "number" ? d.simplicity : 0))),
        Math.max(...feasibilityData.map(d => (typeof d.flexibility === "number" ? d.flexibility : 0)))
      ) + 1;
      const xScale = v => pad + (v - minVal) / (maxVal - minVal) * (W - 2 * pad);
      const yScale = v => (H - pad) - (v - minVal) / (maxVal - minVal) * (H - 2 * pad);
      const usedLabels = [];
      function placeLabel(px, py, text) {
        let labelY = py + 14;
        while (usedLabels.some(([ux, uy]) => Math.abs(uy - labelY) < 10 && Math.abs(ux - px) < 80)) {
          labelY += 14;
        }
        usedLabels.push([px, labelY]);
        ctx.fillText(text, px + 4, labelY);
      }
      ctx.beginPath();
      ctx.moveTo(pad, H - pad);
      ctx.lineTo(W - pad, H - pad);
      ctx.moveTo(pad, H - pad);
      ctx.lineTo(pad, pad);
      ctx.strokeStyle = "#333";
      ctx.lineWidth = 2;
      ctx.stroke();
      function drawFeasTicks() {
        ctx.save();
        ctx.font = "12px sans-serif";
        ctx.fillStyle = "#000";
        for (let v = minVal; v <= maxVal; v++) {
          const x = xScale(v), y0 = yScale(0);
          ctx.beginPath();
          ctx.moveTo(x, y0);
          ctx.lineTo(x, y0 + 5);
          ctx.stroke();
          ctx.fillText(v.toString(), x, y0 + 15);
          const y = yScale(v), x0 = xScale(0);
          ctx.beginPath();
          ctx.moveTo(x0, y);
          ctx.lineTo(x0 - 5, y);
          ctx.stroke();
          ctx.textAlign = "right";
          ctx.textBaseline = "middle";
          ctx.fillText(v.toString(), x0 - 8, y);
        }
        ctx.restore();
      }
      drawFeasTicks();
      ctx.save();
      ctx.fillStyle = "#000";
      ctx.font = "16px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("Simplicity Rank", W / 2, H - 20);
      ctx.translate(20, H / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText("Flexibility Rank", 0, 0);
      ctx.restore();
      const x0 = xScale(minVal), y0 = yScale(minVal);
      const xMax = xScale(maxVal - 0.5), yMax = yScale(maxVal - 0.5);
      ctx.save();
      ctx.strokeStyle = "orange";
      ctx.lineWidth = 3;
      ctx.setLineDash([]);
      ctx.beginPath();
      ctx.moveTo(x0, y0);
      ctx.lineTo(xMax, yMax);
      ctx.stroke();
      ctx.restore();
      feasibilityData.forEach(d => {
        if (typeof d.simplicity !== "number" || typeof d.flexibility !== "number") return;
        const sx = xScale(d.simplicity);
        const sy = yScale(d.flexibility);
        const [px, py] = projectPointToLine(sx, sy, x0, y0, xMax, yMax);
        ctx.save();
        ctx.setLineDash([3, 3]);
        ctx.strokeStyle = "green";
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(sx, sy);
        ctx.lineTo(px, py);
        ctx.stroke();
        ctx.restore();
        ctx.save();
        ctx.strokeStyle = "#1f77b4";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(sx, sy, 5, 0, 2 * Math.PI);
        ctx.stroke();
        ctx.restore();
        ctx.save();
        ctx.fillStyle = "green";
        ctx.beginPath();
        ctx.arc(px, py, 5, 0, 2 * Math.PI);
        ctx.fill();
        ctx.restore();
        ctx.save();
        ctx.font = "14px sans-serif";
        ctx.fillStyle = "#000";
        ctx.textAlign = "left";
        ctx.fillText(d.feasibility, px - 10, py - 6);
        ctx.restore();
        ctx.save();
        ctx.font = "14px sans-serif";
        ctx.fillStyle = "#000";
        ctx.textAlign = "left";
        placeLabel(sx, sy, d.method);
        ctx.restore();
      });
    }

    // ===============================================================
    // Master update and Save functions
    // ===============================================================
    // Use separate update buttons.
    window.onload = () => {
      populateEfficiencyTable();
      populateFeasibilityTable();
      drawEfficiencyPlot();
      drawFeasibilityPlot();
      document.getElementById("updateEfficiencyBtn").addEventListener("click", updateEfficiency);
      document.getElementById("updateFeasibilityBtn").addEventListener("click", updateFeasibility);
      document.getElementById("saveBtn").addEventListener("click", saveDataAndPlots);
    };

    function saveDataAndPlots() {
      const dataObj = { efficiencyData, feasibilityData };
      const dataStr = JSON.stringify(dataObj, null, 2);
      const blob = new Blob([dataStr], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.download = "leaderboard_data.json";
      link.click();
      URL.revokeObjectURL(url);
      function downloadCanvas(id, filename) {
        const c = document.getElementById(id);
        const a = document.createElement("a");
        a.href = c.toDataURL("image/png");
        a.download = filename;
        a.click();
      }
      downloadCanvas("efficiencyCanvas", "efficiency_plot.png");
      downloadCanvas("feasibilityCanvas", "feasibility_plot.png");
    }
  </script>
</body>
</html>
